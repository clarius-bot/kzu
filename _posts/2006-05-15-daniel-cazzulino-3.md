---
layout: post
title: "Daniel Cazzulino"
date: 2006-05-15 00:00:00 +0000
---

Daniel Cazzulino : eXtensible Mind Lounge : Monday, February 16, 2004 - Posts

### Search

[Go](javascript:__doPostBack\('_ctl0$_ctl0$_ctl0$_ctl0$BlogSideBar1$_ctl0$Singleweblogsearch1$_ctl0$SearchButton',''\))

### Subscriptions

  * [RSS 2.0](http://clariusconsulting.net/blogs/kzu/rss.aspx)
  * [Atom 0.3](http://clariusconsulting.net/blogs/kzu/atom.aspx)
  * [Contact](http://clariusconsulting.net/blogs/kzu/contact.aspx)

| [<](javascript:__doPostBack\('_ctl0$_ctl0$_ctl0$_ctl0$BlogSideBar1$_ctl0$Cal$_ctl0$PostCalendar','V2282'\))| May 2006| [>](javascript:__doPostBack\('_ctl0$_ctl0$_ctl0$_ctl0$BlogSideBar1$_ctl0$Cal$_ctl0$PostCalendar','V2343'\))  
---|---|---  
Su| Mo| Tu| We| Th| Fr| Sa  
30| 1| [2](http://clariusconsulting.net/blogs/kzu/archive/2004/2/2.aspx "3 Posts")| 3| [4](http://clariusconsulting.net/blogs/kzu/archive/2004/2/4.aspx "2 Posts")| 5| 6  
7| 8| 9| [10](http://clariusconsulting.net/blogs/kzu/archive/2004/2/10.aspx "2 Posts")| 11| [12](http://clariusconsulting.net/blogs/kzu/archive/2004/2/12.aspx "1 Post")| [13](http://clariusconsulting.net/blogs/kzu/archive/2004/2/13.aspx "1 Post")  
14| 15| [16](http://clariusconsulting.net/blogs/kzu/archive/2004/2/16.aspx "7 Posts")| [17](http://clariusconsulting.net/blogs/kzu/archive/2004/2/17.aspx "2 Posts")| [18](http://clariusconsulting.net/blogs/kzu/archive/2004/2/18.aspx "1 Post")| 19| [20](http://clariusconsulting.net/blogs/kzu/archive/2004/2/20.aspx "3 Posts")  
21| 22| [23](http://clariusconsulting.net/blogs/kzu/archive/2004/2/23.aspx "1 Post")| [24](http://clariusconsulting.net/blogs/kzu/archive/2004/2/24.aspx "1 Post")| [25](http://clariusconsulting.net/blogs/kzu/archive/2004/2/25.aspx "1 Post")| 26| [27](http://clariusconsulting.net/blogs/kzu/archive/2004/2/27.aspx "1 Post")  
28| 29| 30| 31| 1| 2| 3  
4| 5| 6| 7| 8| 9| 10  
  
[![Microsoft MVP Profile](https://web.archive.org/web/20060515183343im_/http://clariusconsulting.net/Themes/default/images/mvp-logo.gif)](http://aspnet2.com/mvp.ashx?kzu)

### Post Categories

  * [All .NET](http://clariusconsulting.net/blogs/kzu/archive/category/1023.aspx) [(rss)](http://clariusconsulting.net/blogs/kzu/rss.aspx?CategoryID=1023)
  * [All Technology](http://clariusconsulting.net/blogs/kzu/archive/category/1035.aspx) [(rss)](http://clariusconsulting.net/blogs/kzu/rss.aspx?CategoryID=1035)
  * [ASP.NET](http://clariusconsulting.net/blogs/kzu/archive/category/1024.aspx) [(rss)](http://clariusconsulting.net/blogs/kzu/rss.aspx?CategoryID=1024)
  * [Books](http://clariusconsulting.net/blogs/kzu/archive/category/1022.aspx) [(rss)](http://clariusconsulting.net/blogs/kzu/rss.aspx?CategoryID=1022)
  * [GAT](http://clariusconsulting.net/blogs/kzu/archive/category/1038.aspx) [(rss)](http://clariusconsulting.net/blogs/kzu/rss.aspx?CategoryID=1038)
  * [Miscelaneous](http://clariusconsulting.net/blogs/kzu/archive/category/1026.aspx) [(rss)](http://clariusconsulting.net/blogs/kzu/rss.aspx?CategoryID=1026)
  * [Movies](http://clariusconsulting.net/blogs/kzu/archive/category/1027.aspx) [(rss)](http://clariusconsulting.net/blogs/kzu/rss.aspx?CategoryID=1027)
  * [Patterns & Practices](http://clariusconsulting.net/blogs/kzu/archive/category/1037.aspx) [(rss)](http://clariusconsulting.net/blogs/kzu/rss.aspx?CategoryID=1037)
  * [Shadowfax](http://clariusconsulting.net/blogs/kzu/archive/category/1032.aspx) [(rss)](http://clariusconsulting.net/blogs/kzu/rss.aspx?CategoryID=1032)
  * [Software Factories](http://clariusconsulting.net/blogs/kzu/archive/category/1041.aspx) [(rss)](http://clariusconsulting.net/blogs/kzu/rss.aspx?CategoryID=1041)
  * [XML](http://clariusconsulting.net/blogs/kzu/archive/category/1021.aspx) [(rss)](http://clariusconsulting.net/blogs/kzu/rss.aspx?CategoryID=1021)

## Monday, February 16, 2004 - Posts

#####  [XVP call (MVPs in XML, that is)](http://clariusconsulting.net/blogs/kzu/archive/2004/02/16/XVPContact.aspx)

I'm looking for all 13 XML MVPs emails, to jointly discuss a proposal in private. The guys I'm looking for are: 

[Kirk Allen Evans](http://blogs.xmladvice.com/kaevans)  
Bjoern Hoehrmann  
J. Michael Palermo IV  
[Jeff Alan Julian](http://geekswithblogs.net/jjulian/)  
[Donald Paul Demcsak, Jr.](http://donxml.com/allthingstechie/Rss.aspx)  
Joe Fawcett  
Julian Reschke  
Kuniyasu Yakushiji  
Sei Yakushiji  
Yoshihiro Yamada  

The mails I already know of:  
[Christoph Schittko](http://weblogs.asp.net/cschittko/Rss.aspx)  
[Oleg Tkachenko](http://www.tkachenko.com/blog/index.rdf)  
Dimitre Dimitrov Novatchev

My email is kzu AT aspnet2 NO SPAM PLZ DOT com 

posted [Monday, February 16, 2004 5:07 PM](http://clariusconsulting.net/blogs/kzu/archive/2004/02/16/XVPContact.aspx) by [kzu](http://clariusconsulting.net/user/Profile.aspx?UserID=1004) with [0 Comments](http://clariusconsulting.net/blogs/kzu/archive/2004/02/16/XVPContact.aspx#comments)

#####  [ForwardXPathNavigator vs XSE](http://clariusconsulting.net/blogs/kzu/archive/2004/02/16/163.aspx)

[Oleg](http://www.tkachenko.com/blog/archives/000161.html) has posted his code now too. I guess this way we're encouraging mutually to release code often ;). I must defend: 

> (btw, I'm musing if I have to adopt hype-before-release strategy? :).

Honestly, I was porting the code to v1.x :o). 

Back to the issue, there's a fundamental difference in the approach between his class and my XSE API: his will consume the stream with a single query. Mine supports multiple handlers matching multiple elements at the same time. And it's still a pull-based API, where you have to iterate results, instead of being called when something you care happened (was matched). I look forward his XmlUpdater!

posted [Monday, February 16, 2004 4:17 PM](http://clariusconsulting.net/blogs/kzu/archive/2004/02/16/163.aspx) by [kzu](http://clariusconsulting.net/user/Profile.aspx?UserID=1004) with [0 Comments](http://clariusconsulting.net/blogs/kzu/archive/2004/02/16/163.aspx#comments)

#####  [XSE != XPath != SXPath != XPathReader](http://clariusconsulting.net/blogs/kzu/archive/2004/02/16/XseNotXPath.aspx)

[Dare](http://www.25hoursaday.com/weblog/CommentView.aspx?guid=a333b9f4-0a67-45fd-913d-3b9bc37cf4b6) argues that my [Xml Streaming Events](http://weblogs.asp.net/cazzu/posts/XseIntro.aspx) API can't support queries like the following:

/r:feeds/r:feed[count(r:stories-recently-viewed)>10]/r:title

And argues that I'm adding extensions to XPath. I've mentioned in [a previous post](http://weblogs.asp.net/cazzu/posts/PseudoXPath.aspx) that I'm not doing that. I'm not *supporting* XPath. Therefore, the query testing for count of children won't work (for now). But the issue is a different one: XSE is not about querying with an specific expression language/format (i.e. XPath or SXPath). XSE is just a mechanism for encapsulating state machines checking for matches against a given expression. What the expression looks like depends on the factory that creates the strategy.   
Therefore, the factories I showed (i.e. my RootedPath and RelativePath) are only encapsulating code generation for different FSMs, based on an expression language that fits a need. Therefore, I could even create a factory implementing SXPath and still remain in Xml Streaming Events land. The XSE idea is to provide a callback metaphor to XML parsing, instead of the pull-model of the XmlReader. In fact, it's a sort of evolution over SAX, in that at the same time it offers both worlds: pull model directly from the XseReader, events-based for your registered handlers.

posted [Monday, February 16, 2004 4:04 PM](http://clariusconsulting.net/blogs/kzu/archive/2004/02/16/XseNotXPath.aspx) by [kzu](http://clariusconsulting.net/user/Profile.aspx?UserID=1004) with [0 Comments](http://clariusconsulting.net/blogs/kzu/archive/2004/02/16/XseNotXPath.aspx#comments)

#####  [XSE Initial Release](http://clariusconsulting.net/blogs/kzu/archive/2004/02/16/XSERelease.aspx)

After the [introduction](http://weblogs.asp.net/cazzu/posts/XseIntro.aspx), [some use cases](http://weblogs.asp.net/cazzu/posts/XseTransformations.aspx) and [other stuff](http://weblogs.asp.net/cazzu/posts/XPathNonNs.aspx) that can be done with it, I've finally uploaded the NMatrix.Xml project containing XSE (I will unify Schematron here later). You can download it from the [ASPNET2](http://aspnet2.com/) incubator:  
[.NET 1.x version](http://aspnet2.com/incubator/code/NMatrix.Xml-v1.zip)  
[.NET Whidbey version](http://aspnet2.com/incubator/code/NMatrix.Xml-v2.zip)  

**Update: read these follow-up:**

  * [XSE != XPath != SXPath != XPathReader](http://weblogs.asp.net/cazzu/archive/2004/02/16/XseNotXPath.aspx)

posted [Monday, February 16, 2004 9:51 AM](http://clariusconsulting.net/blogs/kzu/archive/2004/02/16/XSERelease.aspx) by [kzu](http://clariusconsulting.net/user/Profile.aspx?UserID=1004) with [0 Comments](http://clariusconsulting.net/blogs/kzu/archive/2004/02/16/XSERelease.aspx#comments)

#####  [XPath vs pseudo-XPath](http://clariusconsulting.net/blogs/kzu/archive/2004/02/16/PseudoXPath.aspx)

[Oleg](http://www.tkachenko.com/blog/archives/000159.html) commented on my [XSE (Xml Streaming Events)](http://weblogs.asp.net/cazzu/posts/XSEIntro.aspx) implementation. He has a nice code snipped with something called an XmlUpdater. Really cool. I'd like to see that code!  

He has a couple of observations about my wildcard syntax. Clarifying them:  
":*" = any element with an empty namespace.  
"*.*" = any element in any namespace.   
Those are different things ;).   
All available wildcards are explained in [the previous post](http://weblogs.asp.net/cazzu/posts/XseTransformations.aspx), towards the end. 

Strictly speaking, his forwardonly navigator is not XPath either, just like my two initial XSE factories. XPath is a very concrete concept and specification. If I'm not going to support it, well, I don't need to care about its syntax, providing I give users something easy to understand. I believe the wildcards are FAR more easier to grasp than the `local-name` and `namespace-uri` XPath counterparts.   
The `RootedPath` and `RelativePath` are just factories for concrete compiled algorithms that are different in implementation (codegen). Note there's no X in the middle, so it's no XPath at all ;).  
Of course, calling something akin to folder browsing anything else than "path" would be unnatural, that's why I chose it. 

My idea was to implement compiled algorithms that (IMO) will always be more performant than generic ones. In the code download I even provide an `InterpretedPath` factory that does just this. Doesn't compile anything and evaluates dynamically. There's a price to pay, just like I guessed. 

Bottom lines: 

  * Naming XPath things that are not, confuses developers.
  * Seeking XPath support where it's overkill is not wise, IMO.
  * XPath will NEVER be available in streaming APIs.
  * Having path-like expression syntax for streaming XML handling can hardly be called "reinventing the wheel". You have to choose the solution that best applies to your problem. Call it whatever you like ;).

**Update: read these follow-up:**

  * [XSE Initial Release](http://weblogs.asp.net/cazzu/archive/2004/02/16/XSERelease.aspx)
  * [XSE != XPath != SXPath != XPathReader](http://weblogs.asp.net/cazzu/archive/2004/02/16/XseNotXPath.aspx)

posted [Monday, February 16, 2004 9:50 AM](http://clariusconsulting.net/blogs/kzu/archive/2004/02/16/PseudoXPath.aspx) by [kzu](http://clariusconsulting.net/user/Profile.aspx?UserID=1004) with [0 Comments](http://clariusconsulting.net/blogs/kzu/archive/2004/02/16/PseudoXPath.aspx#comments)

#####  [XPath queries without namespace: XSE to the rescue](http://clariusconsulting.net/blogs/kzu/archive/2004/02/16/XPathNonNS.aspx)

[Dare](http://www.25hoursaday.com/weblog/PermaLink.aspx?guid=cd6f9ffd-5149-4872-b48c-0f95f4fdd3bf) has posted about issues with XPath and namespaces in documents. I'm by no means encouraging this, but if you don't care about namespaces, here's a solution for you.

[Using the](http://weblogs.asp.net/cazzu/posts/XseTransformations.aspx) [XSE reader](http://weblogs.asp.net/cazzu/posts/XseIntro.aspx) I proposed (~~and will upload real soon~~[ see the release post](http://weblogs.asp.net/cazzu/posts/XSERelease.aspx)), you can setup a handler to catch all elements and remove any namespaces whatsoever, at reading time (i.e. long before the document is loaded), as follows:

public class MyLoader { public XPathDocument Load(string uri) { TransformingXseReader xr = new TransformingXseReader(new XmlTextReader(uri)); XmlNamespaceManager mgr = new XmlNamespaceManager(xr.NameTable); xr.AddHandler(new RelativePath().Create("*", mgr), new EventHandler(OnElement)); XPathDocument doc = new XPathDocument(xr); return doc; } private void OnElement(object sender, EventArgs e) { TransformingXseReader tr = (TransformingXseReader) sender; tr.ChangeName(tr.LocalName, String.Empty); } }

The Whidbey version looks more compact:

public class MyLoader { public XPathDocument Load(string uri) { TransformingXseReader xr = new TransformingXseReader(new XmlTextReader(uri)); XmlNamespaceManager mgr = new XmlNamespaceManager(xr.NameTable); xr.AddHandler(new RelativePath().Create("*", mgr), delegate { xr.ChangeName(xr.LocalName, String.Empty); } XPathDocument doc = new XPathDocument(xr); return doc; } }

What you effectively get loaded is an infoset without element namespaces, therefore your XPath queries don't need to care about them anymore.

**Update: read these follow-up:**

  * [XPath vs pseudo-XPath](http://weblogs.asp.net/cazzu/archive/2004/02/16/PseudoXPath.aspx)
  * [XSE Initial Release](http://weblogs.asp.net/cazzu/archive/2004/02/16/XSERelease.aspx)
  * [XSE != XPath != SXPath != XPathReader](http://weblogs.asp.net/cazzu/archive/2004/02/16/XseNotXPath.aspx)

posted [Monday, February 16, 2004 9:49 AM](http://clariusconsulting.net/blogs/kzu/archive/2004/02/16/XPathNonNS.aspx) by [kzu](http://clariusconsulting.net/user/Profile.aspx?UserID=1004) with [1 Comments](http://clariusconsulting.net/blogs/kzu/archive/2004/02/16/XPathNonNS.aspx#comments)

#####  [Xml Streaming Events: simple streaming Xml handing (and changing) at work.](http://clariusconsulting.net/blogs/kzu/archive/2004/02/16/XseTransformations.aspx)

I presented XSE (Xml Streaming Events) in [ a previous post](http://weblogs.asp.net/cazzu/posts/XseIntro.aspx). In this post I will show some examples of what can be acomplished with it in a streaming (therefore performant) way. 

IMPORTANT NOTICE: for anyone not playing with Whidbey, all statements that look like `delegate { ... //.net code ... }` can be replaced with the usual v1.x `new EventHandler( yourMethod )` where the method implements the code inside the brackets.

## Upgrading namespaces

Sometimes there's a need to perform some on-the-fly change in a document stream. For example, imagine you have upgraded your schemas to a different namespace (i.e. from `xmlns:kzu="http://kzu.aspnet2.com/2003/schematron"` to ` xmlns:kzu="http://kzu.aspnet2.com/2004/schematron")`. I know there are several discussions all over the web (see [Dare's post](http://www.25hoursaday.com/weblog/PermaLink.aspx?guid=4d18d061-8895-46e0-b5b5-7d51c7fb8898), [David Orchad's](http://www.pacificspirit.com/blog/2004/01/19/providing_compatible_schema_evolution), etc.) on schema versioning, and most (including me) agree that changing the namespace name is not versioning at all. It's a whole new schema. Aside from that, there are concrete cases where this has happened and will happen, as well as your own business requirements. Right now I can think of WXS and SOAP as two concrete examples. With XSE, it can be achieved easily at the reader level (that is, BEFORE you even load a `SoapMessage`, `XPathDocument` or whatever): 

// Upgrading namespaces TransformingXseReader xr = new TransformingXseReader(new XmlTextReader(input)); XmlNamespaceManager mgr = new XmlNamespaceManager(xr.NameTable); mgr.AddNamespace("kzu", "http://kzu.aspnet2.com/2003/schematron"); xr.AddHandler(new RelativePath().Create("kzu:*", mgr), delegate { // Upgrade to 2004 namespace. Keep original element name. xr.ChangeName(xr.LocalName, "http://kzu.aspnet2.com/2004/schematron"); });

Note that the transformation feature is layered on top of the base `XseReader` so that I only have to pay the performance cost for what I use. If I don't need modifications to the InfoSet, I don't have to pay for the cost of checks for transformations. A document loaded with this reader will see an infoset complying with the new namespace. I can hand this reader to an `XmlValidatingReader` and have it validated against the new schema (remember there's a [known](http://weblogs.asp.net/cazzu/archive/2003/11/06/36209.aspx) [bug]() in v1.x validating reader that prevents this, but it has been fixed in v2). Note that because we're matching with a wildcard, this works at any level in the document. For example, the following document: 

Is upgraded as follows:

Note that a root-element namespace change alone is not enough. So, in order to achieve similar functionality today, a full string loading and find&replace would need to be issued. Again, full streaming support is a top priority for XSE.

## Simple element name transformations

Another common use case is simple name changes in a document. For example, an incoming document may have a `<customer>` element when you expect a `<person>`, or an `<orderDate>` when you need an `<ordered>` element. XSE removes the need for full document loading and XSLT stylesheet creation and processing that would be required for such a simple case:

// Changing names TransformingXseReader xr = new TransformingXseReader(new XmlTextReader(input)); XmlNamespaceManager mgr = new XmlNamespaceManager(xr.NameTable); mgr.AddNamespace("crm", "http://thirparty.crm.com/"); xr.AddHandler(new RelativePath().Create("crm:customer", mgr), delegate { // Upgrade our person element and namespace xr.ChangeName(xr.NameTable.Add("person"), "http://kzu.aspnet2.com/"); });

Note that I changed at the same time the element name and namespace. 

## Simple content adaptation

In the above example, I showed changing a `<customer>` element name and namespace to the expected `<person> `one. Combined with node skipping, I can adapt (sort-of downgrade in this case) the former element to your desired representation. For example, if the `<customer>` element includes a `<contact>` children that our `<person>` element doesn't expect, I can simply skip it:

TransformingXseReader xr = new TransformingXseReader(new XmlTextReader(input)); XmlNamespaceManager mgr = new XmlNamespaceManager(xr.NameTable); mgr.AddNamespace("crm", "http://thirparty.crm.com/"); xr.AddHandler(new RelativePath().Create("crm:customer", mgr), delegate { // Upgrade our person element and namespace xr.ChangeName(xr.NameTable.Add("person"), "http://kzu.aspnet2.com/"); }); xr.AddHandler(new RelativePath().Create("crm:contact", mgr), delegate { // Skip this element as I'm not interested in it or it's unsupported in my schema xr.Skip(); });

## Transparent elements and namespaces

James Clark [has proposed](http://www.idealliance.org/papers/dx_xml03/papers/04-05-03/04-05-03.html) what he calls Transparent namespaces in his [Namespace Routing Language (NRL)](http://xml.coverpages.org/Clark-NRL-Announce.html) proposal, which may make it into the [ISO/IEC 19757 Document Schema Definition Languages (DSDL)](http://www.dsdl.org/). He gives examples where it is useful to have an element ignored from the stream, as if it didn't exist at all, but without losing its content. This is different than `XmlReader.Skip()` method in that the later stops parsing the skipped element's children. He gives as an example an XSLT stylesheet containing XHTML, for example:

  * 

It's impossible to validate the XHTML against the corresponding schema, unless you modify it accordingly to include extension points all over the place. The proposed solution is to make the xsl:* elements transparent for the validation process, while retaining their children. James proposes this "transparentizing" at the namespace level. This can be easily achieved with XSE: 

// Transparentize TransformingXseReader xr = new TransformingXseReader(new XmlTextReader(input)); XmlNamespaceManager mgr = new XmlNamespaceManager(xr.NameTable); mgr.AddNamespace("xsl", "http://www.w3.org/1999/XSL/Transform"); xr.AddHandler(new RelativePath().Create("xsl:*", mgr), delegate { // Turns all XSLT elements transparent. xr.MakeTransparent(); });

Note that I'm using a special wildcard supported by XSE. Wildcard options are: 

  * * : mathes any element in any namespace. Is equivalent to `*:*`.
  * *:item : matches an item with a `LocalName="item"`, irrespective of namespace.
  * kzu:* : matches any element in the namespace mapped to the "kzu" prefix by the `XmlNamespaceManager`.
  * :* : matches any element with a `NamespaceURI=""`. Note that this is not the same as `*:*` (first option). 

Therefore, making elements transparent is supported at a more granular level than that proposed by James. If a document is loaded (or a `ReadOuterXml()` is performed on the reader), the following infoset is seen: 

  * 

And of course, as the implementation supports streaming scenarios, you can pass it to the next processing hop without ever loading the entire stream. Another example is processing the body of a SOAP message:

TransformingXseReader xr = new TransformingXseReader(new XmlTextReader(input)); XmlNamespaceManager mgr = new XmlNamespaceManager(xr.NameTable); mgr.AddNamespace("soap", "http://schemas.xmlsoap.org/soap/envelope/"); IStrategyFactory relative = new RelativePath(); xr.AddHandler(new RootedPath().Create("soap:Envelope", mgr), delegate { // Preserve the envelope contents. xr.MakeTransparent(); }); xr.AddHandler(relative.Create("soap:Header", mgr), delegate { // Don't bother about headers. xr.Skip(); }); xr.AddHandler(relative.Create("soap:Body", mgr), delegate { // Definitely keep the body content. xr.MakeTransparent(); });

Handing this reader to the processing phase will result in only the contents of the `soap:Body` to be seen.

## Skip irrelevant content

Finally, if we're processing XML with mixed namespaces, it may be the case that our application only cares about elements from our own namespace. In such cases, loading irrelevant nodes in a document is a clear waste of resources. We can choose to make those other nodes transparent or skip them altogether:

TransformingXseReader xr = new TransformingXseReader(new XmlTextReader(input)); XmlNamespaceManager mgr = new XmlNamespaceManager(xr.NameTable); mgr.AddNamespace("dc", "http://purl.org/dc/elements/1.1/"); mgr.AddNamespace("rdf", "http://www.w3.org/1999/02/22-rdf-syntax-ns#"); IStrategyFactory relative = new RelativePath(); xr.AddHandler(relative.Create("dc:*", mgr), delegate { // Skip Dublin Core elements. xr.Skip(); }); xr.AddHandler(relative.Create("rdf:*", mgr), delegate { // Make RDF elements transparent. xr.MakeTransparent(); });

I still have to decide on what syntax would be the most convenient way to say "match everthing that is NOT in this namespace". Options I can think of are:

  1. ^kzu:* 
  2. !kzu:* 
  3. Create another strategy factory that interprets the matches as negative asserts instead of positives. i.e.: IMatchStrategy nonblank = new NegativeRelativePath().Create(":*"); Instead of matching anything with a blank namespace would match anything with a non-blank NamespaceURI. 

As usual, I look forward your feedback as I finish setting up the opensource project for this.

**Update: read these follow-up:**

  * [XPath queries without namespace: XSE to the rescue](http://weblogs.asp.net/cazzu/archive/2004/02/16/XPathNonNS.aspx)
  * [XPath vs pseudo-XPath](http://weblogs.asp.net/cazzu/archive/2004/02/16/PseudoXPath.aspx)
  * [XSE Initial Release](http://weblogs.asp.net/cazzu/archive/2004/02/16/XSERelease.aspx)
  * [XSE != XPath != SXPath != XPathReader](http://weblogs.asp.net/cazzu/archive/2004/02/16/XseNotXPath.aspx)

posted [Monday, February 16, 2004 9:47 AM](http://clariusconsulting.net/blogs/kzu/archive/2004/02/16/XseTransformations.aspx) by [kzu](http://clariusconsulting.net/user/Profile.aspx?UserID=1004) with [0 Comments](http://clariusconsulting.net/blogs/kzu/archive/2004/02/16/XseTransformations.aspx#comments)

  

[![](/web/20060515183343im_/http://clariusconsulting.net/Themes/default/images/hdr-KZU.jpg)](http://clariusconsulting.net/blogs "Clarius Aggregated Blogs")