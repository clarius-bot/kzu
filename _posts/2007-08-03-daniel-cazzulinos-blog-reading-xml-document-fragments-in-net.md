---
layout: post
title: "Daniel Cazzulino's Blog : Reading XML document fragments in .NET"
date: 2007-08-03 00:00:00 +0000
---

Daniel Cazzulino's Blog : Reading XML document fragments in .NET

### Search

[Go](javascript:__doPostBack\('_ctl0$_ctl0$_ctl0$_ctl0$BlogSideBar1$_ctl0$Singleweblogsearch1$_ctl0$SearchButton',''\))

### Subscriptions

  * [RSS 2.0](http://www.clariusconsulting.net/blogs/kzu/rss.aspx)
  * [Atom 0.3](http://www.clariusconsulting.net/blogs/kzu/atom.aspx)
  * [Contact](http://www.clariusconsulting.net/blogs/kzu/contact.aspx)

| [<](javascript:__doPostBack\('_ctl0$_ctl0$_ctl0$_ctl0$BlogSideBar1$_ctl0$Cal$_ctl0$PostCalendar','V3013'\))| May 2008| [>](javascript:__doPostBack\('_ctl0$_ctl0$_ctl0$_ctl0$BlogSideBar1$_ctl0$Cal$_ctl0$PostCalendar','V3074'\))  
---|---|---  
Su| Mo| Tu| We| Th| Fr| Sa  
27| 28| 29| 30| 1| 2| [3](http://www.clariusconsulting.net/blogs/kzu/archive/2007/8/3.aspx "1 Post")  
4| [5](http://www.clariusconsulting.net/blogs/kzu/archive/2007/8/5.aspx "1 Post")| 6| 7| 8| 9| 10  
11| 12| 13| 14| 15| 16| 17  
18| 19| [20](http://www.clariusconsulting.net/blogs/kzu/archive/2007/8/20.aspx "1 Post")| [21](http://www.clariusconsulting.net/blogs/kzu/archive/2007/8/21.aspx "2 Posts")| 22| 23| [24](http://www.clariusconsulting.net/blogs/kzu/archive/2007/8/24.aspx "2 Posts")  
25| 26| 27| 28| 29| 30| 31  
1| 2| 3| 4| 5| 6| 7  
  
[![Microsoft MVP Profile](https://web.archive.org/web/20080530060418im_/http://clariusconsulting.net/Themes/default/images/mvp-logo.gif)](http://aspnet2.com/mvp.ashx?kzu)

### News

[![](https://web.archive.org/web/20080530060418im_/http://www.feedburner.com/fb/images/pub/feed-icon16x16.png)](http://feeds.feedburner.com/DanielCazzulino) [](http://feeds.feedburner.com/DanielCazzulino) [![](https://web.archive.org/web/20080530060418im_/http://feeds.feedburner.com/~fc/DanielCazzulino?bg=FF6600&fg=FFFFFF&anim=1)](http://feeds.feedburner.com/DanielCazzulino)

[ ![](/web/20080530060418im_/http://www.clariusconsulting.net/img/mail-to-button.gif) Contact](http://www.clariusconsulting.net/blogs/kzu/contact.aspx)

### Post Categories

  * [.NET](http://www.clariusconsulting.net/blogs/kzu/archive/category/1023.aspx) [(rss)](http://www.clariusconsulting.net/blogs/kzu/rss.aspx?CategoryID=1023)
  * [All Technology](http://www.clariusconsulting.net/blogs/kzu/archive/category/1035.aspx) [(rss)](http://www.clariusconsulting.net/blogs/kzu/rss.aspx?CategoryID=1035)
  * [ASP.NET](http://www.clariusconsulting.net/blogs/kzu/archive/category/1024.aspx) [(rss)](http://www.clariusconsulting.net/blogs/kzu/rss.aspx?CategoryID=1024)
  * [Books](http://www.clariusconsulting.net/blogs/kzu/archive/category/1022.aspx) [(rss)](http://www.clariusconsulting.net/blogs/kzu/rss.aspx?CategoryID=1022)
  * [GAT](http://www.clariusconsulting.net/blogs/kzu/archive/category/1038.aspx) [(rss)](http://www.clariusconsulting.net/blogs/kzu/rss.aspx?CategoryID=1038)
  * [InSTEDD](http://www.clariusconsulting.net/blogs/kzu/archive/category/1064.aspx) [(rss)](http://www.clariusconsulting.net/blogs/kzu/rss.aspx?CategoryID=1064)
  * [Mesh](http://www.clariusconsulting.net/blogs/kzu/archive/category/1065.aspx) [(rss)](http://www.clariusconsulting.net/blogs/kzu/rss.aspx?CategoryID=1065)
  * [Miscelaneous](http://www.clariusconsulting.net/blogs/kzu/archive/category/1026.aspx) [(rss)](http://www.clariusconsulting.net/blogs/kzu/rss.aspx?CategoryID=1026)
  * [Moq](http://www.clariusconsulting.net/blogs/kzu/archive/category/1062.aspx) [(rss)](http://www.clariusconsulting.net/blogs/kzu/rss.aspx?CategoryID=1062)
  * [Movies](http://www.clariusconsulting.net/blogs/kzu/archive/category/1027.aspx) [(rss)](http://www.clariusconsulting.net/blogs/kzu/rss.aspx?CategoryID=1027)
  * [Patterns & Practices](http://www.clariusconsulting.net/blogs/kzu/archive/category/1037.aspx) [(rss)](http://www.clariusconsulting.net/blogs/kzu/rss.aspx?CategoryID=1037)
  * [PowerShell](http://www.clariusconsulting.net/blogs/kzu/archive/category/1055.aspx) [(rss)](http://www.clariusconsulting.net/blogs/kzu/rss.aspx?CategoryID=1055)
  * [Shadowfax](http://www.clariusconsulting.net/blogs/kzu/archive/category/1032.aspx) [(rss)](http://www.clariusconsulting.net/blogs/kzu/rss.aspx?CategoryID=1032)
  * [Software Factories](http://www.clariusconsulting.net/blogs/kzu/archive/category/1041.aspx) [(rss)](http://www.clariusconsulting.net/blogs/kzu/rss.aspx?CategoryID=1041)
  * [WPF](http://www.clariusconsulting.net/blogs/kzu/archive/category/1060.aspx) [(rss)](http://www.clariusconsulting.net/blogs/kzu/rss.aspx?CategoryID=1060)
  * [XML](http://www.clariusconsulting.net/blogs/kzu/archive/category/1021.aspx) [(rss)](http://www.clariusconsulting.net/blogs/kzu/rss.aspx?CategoryID=1021)

## Reading XML document fragments in .NET 

A document fragment is an XML file that doesn't have a root element:
    
    
    <E2ETraceEvent xmlns="http://schemas.microsoft.com/2004/06/E2ETraceEvent">
      <System xmlns="http://schemas.microsoft.com/2004/06/windows/eventlog/system">  
        ...
      </System>
      <ApplicationData>  
        ...
      </ApplicationData>
    </E2ETraceEvent>
    <E2ETraceEvent xmlns="http://schemas.microsoft.com/2004/06/E2ETraceEvent">
      <System xmlns="http://schemas.microsoft.com/2004/06/windows/eventlog/system">  
        ...
      </System>
      <ApplicationData>  
        ...
      </ApplicationData>
    </E2ETraceEvent>
    ...
    
    
    Â 

In order to read this with plain XmlReader code, you can do the following:
    
    
    XmlReaderSettings settings = new XmlReaderSettings();
    settings.ConformanceLevel = ConformanceLevel.Fragment;
    
    using (XmlReader reader = XmlReader.Create("tracelog.xml", settings))
    {
        while (reader.Read())
        {
            // Process each node of the fragment, 
            // possibly using reader.ReadSubtree()
        }
    }
    

[](http://11011.net/software/vspaste)

It may be the case that instead of the more performant (and definitely suggested approach if the file is big) XmlReader API, you may want to use XmlDocument or XPathDocument to be able to query the file using full XPath. In .NET 2.0, the XPathDocument class will successfully load an xml fragment, which was kind of surprising to me as I'm pretty sure it was not a supported feature in .NET 1.1. The surprising part is because technically, a fragment is NOT a document. The way the XPathDocument does its magic is by creating a "transparent" root node, and holding the fragments from it. I say it's transparent because your XPath queries can use the root node axis and still get properly resolved to the fragments:
    
    
    private void LoadXPath(object sender, EventArgs e)
    {
        string xml = @"<item id='1' /><item id='2'/>";
    
        XmlReaderSettings set = new XmlReaderSettings();
        set.ConformanceLevel = ConformanceLevel.Fragment;
    
        XPathDocument doc = new XPathDocument(
            XmlReader.Create(new StringReader(xml), set));
    
        XPathNavigator nav = doc.CreateNavigator();
    
        Debug.Assert(nav.Select("/item").Count == 2);
    }
    

[](http://11011.net/software/vspaste)

Note how the query is "/item", which would return the single root element in a regular XML document, but here it returns the two items which are hanging from the "transparent" root (that's why I call it such, as there's no way to "see" it, not even by using the OuterXml on an XPathNavigator sitting on the root). 

If you're more of an XmlDocument guy, or maybe you need to perform updates to the fragments using random access via XPath queries too, then you're pretty much out of luck, as the XmlDocument will fails with a "System.Xml.XmlException: There are multiple root elements. Line x, position y." exception if you try to load an xml fragment (via string or XmlReader, doesn't matter). 

Here's where a new class we added to the [Mvp.Xml](http://www.codeplex.com/MVPXML "MVP XML Library at CodePlex") library can help: XmlFragmentReader. This is an XmlReader-derived class which receives a root element name (and optionally a namespace) to fake a root node. Because it's an XmlReader class, it does so in a streaming fashion, and shouldn't have an impact in reading performance, as all its members just pass-through to the base reader (the one reading the fragments) except on the initial state and the ending one (where the fake root is reported). Usage is straighforward:
    
    
    private void LoadXml(object sender, EventArgs e)
    {
        string xml = @"<item /><item/>";
    
        XmlDocument doc = new XmlDocument();
    
        XmlReaderSettings set = new XmlReaderSettings();
        set.ConformanceLevel = ConformanceLevel.Fragment;
    
        using (XmlReader reader = **new XmlFragmentReader("root",**
            XmlReader.Create(new StringReader(xml), set)))
        {
            doc.Load(reader);                
        }
    
        Debug.Assert(doc.SelectNodes("/root/item").Count == 2);
    }
    

Note that the root node is not transparent as is the case with the XPathDocument, so you have to include it in your XPath queries.

[Get the Mvp.Xml library](http://www.codeplex.com/MVPXML) and enjoy! 

posted on Friday, August 03, 2007 5:28 PM by [kzu](http://www.clariusconsulting.net/user/Profile.aspx?UserID=1004)

[Post a Comment](http://www.clariusconsulting.net/blogs/kzu/comments/29281.aspx) :: 

  

[![](/web/20080530060418im_/http://www.clariusconsulting.net/Themes/default/images/hdr-KZU.jpg)](http://clariusconsulting.net/blogs "Clarius Aggregated Blogs")